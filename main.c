#pragma config(Sensor, dgtl1,           DRIVE_MOTOR_ENCODER_LEFT,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,           DRIVE_MOTOR_ENCODER_RIGHT,   sensorQuadEncoder)
#pragma config(Motor,  port2,           DRIVE_MOTOR_LEFT,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           LIFT_STAGE_2,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           LIFT_STAGE_3,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           CLAW_MOTOR,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           LIFT_STAGE_1,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           DRIVE_MOTOR_RIGHT,    tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

#include "Vex_Competition_Includes.c"   // Main competition background code...do not modify!
#include "driveFunctions.c"             // Custom Drive Functions


/*
 //
 //  ,--.   ,--.,------.,--.   ,--.     ,---.  ,--.                    ,--.
 //   \  `.'  / |  .---' \  `.'  /     '   .-' |  |,-. ,--. ,--.,--.--.`--' ,---.  ,---.
 //    \     /  |  `--,   .'    \      `.  `-. |     /  \  '  / |  .--',--.(  .-' | .-. :
 //     \   /   |  `---. /  .'.  \     .-'    ||  \  \   \   '  |  |   |  |.-'  `)\   --.
 //      `-'    `------''--'   '--'    `-----' `--'`--'.-'  /   `--'   `--'`----'  `----'
 //   ,---.   ,--.   ,--.,-----.                       `---'
 //  '.-.  \ /    \ /   ||  .--'
 //   .-' .'|  ()  |`|  |'--. `\
 //  /   '-. \    /  |  |.--'  /
 //  '-----'  `--'   `--'`----'
 //  ,--------.                              ,--.  ,---.   ,---. ,---.
 //  '--.  .--',---.  ,--,--.,--,--,--.     /  .' |  o  | /    || o   \
 //     |  |  | .-. :' ,-.  ||        |    |  .-. .'   './  '  |`..'  |
 //     |  |  \   --.\ '-'  ||  |  |  |    \   o ||  o  |'--|  | .'  /
 //     `--'   `----' `--`--'`--`--`--'     `---'  `---'    `--' `--'
 //
 //
 //
 //
 //
 //  ______      _ _   _____      _  __  __ _
 //  | ___ \    | | | |  __ \    (_)/ _|/ _(_)
 //  | |_/ / ___| | | | |  \/_ __ _| |_| |_ _ _ __  ___
 //  | ___ \/ _ \ | | | | __| '__| |  _|  _| | '_ \/ __|
 //  | |_/ /  __/ | | | |_\ \ |  | | | | | | | | | \__ \
 //  \____/ \___|_|_|  \____/_|  |_|_| |_| |_|_| |_|___/
 //
 //
 */






/*
//
//  Global Constants
//
*/


const int FULL_FORWARD      =   127;
const int OFF               =   0;
const int FULL_REVERSE      =   -127;


task tankDrive() {
    
    while (true) {
        motor [DRIVE_MOTOR_RIGHT] = vexRT[Ch2];
        motor [DRIVE_MOTOR_LEFT] = vexRT[Ch3];
    }
    
    EndTimeSlice();
}

task claw() {
    while (true) {
        if (vexRT[Btn8U] == 1) {
            motor[CLAW_MOTOR]   =   FULL_FORWARD;
        }
        else if (vexRT[Btn8D] == 1) {
            motor[CLAW_MOTOR]   =   FULL_REVERSE;
        }
        else {
            motor[CLAW_MOTOR]   =   OFF;
        }
    }
}

////////////////////////////////////////////////////////


task stage1() {
    while (true) {
        
        if (vexRT[Btn5U] == 1) {
            motor[LIFT_STAGE_1] = FULL_FORWARD;
        }
        else if (vexRT[Btn5D] == 1) {
            motor[LIFT_STAGE_1] = FULL_REVERSE;
        }
        else {
            motor[LIFT_STAGE_1] = OFF;
        }
        
        
        EndTimeSlice();
        
        
        
        
    }//END OF WHILE LOOP
    
    
    
}//End of STAGE1 TASK
////////////////////////////////////////////////////////////////////////////////////////

task stage2() {
    while (true) {
        
        if (vexRT[Btn6U] == 1) {
            motor[LIFT_STAGE_2] = FULL_FORWARD;
        }
        else if (vexRT[Btn6D] == 1) {
            motor[LIFT_STAGE_2] = FULL_REVERSE;
        }
        else {
            motor[LIFT_STAGE_2] = OFF;
        }
        
        
        EndTimeSlice();
        
        
        
        
    }//END OF WHILE LOOP
    
    
    
}//End of STAGE1 TASK
////////////////////////////////////////////////////////////////////////////////////////

task stage3() {
    while (true) {
        
        if (vexRT[Btn7U] == 1) {
            motor[LIFT_STAGE_3] = FULL_FORWARD;
        }
        else if (vexRT[Btn7D] == 1) {
            motor[LIFT_STAGE_3] = FULL_REVERSE;
        }
        else {
            motor[LIFT_STAGE_3] = OFF;
        }
        
        EndTimeSlice();
        
        
        
        
    }//END OF WHILE LOOP
    
    
    
}



/*
//
//  Competition Tasks
//
*/


void pre_auton()
{

    bStopTasksBetweenModes = true;

}



task autonomous()
{
    AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}




task usercontrol()
{

    while (true)
    {
        startTask(tankDrive);
        startTask(stage1);
        startTask(stage2);
        startTask(stage3);
        startTask(claw);
    }
}













